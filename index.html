<!doctype html>
<html>
<head>
  <title>Arogi Maximal Cover</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  <link rel="stylesheet" href="leaflet/leaflet.css" />
  <link rel="stylesheet" href="arogi_dark.css" />
  <script src="leaflet/leaflet.js"></script>
  <script src="https://mapzen.com/tangram/0.6/tangram.min.js"></script>

  <!-- // this loads a geojson of starting points.
  // the variable is called defaultMarkers -->
  <script src="data/mclp_data_500.js"></script>


  <style>

  body {
    padding: 0;
    margin: 0;
  }

  #map {
    height: 100%;
    width: 100%;
    padding:0px;
    margin:0px;
    position: absolute;
  }

  </style>
</head>

<body>
  <div id="map"></div>

  <div id="arogi-menu-main">
    <div id="arogi-top-zone">Maximal Cover</div>
    <div id="arogi-menu-upper">Parameters</div>

    <div id="arogi-menu-middle">

      <span class="parameterLabels">facilities</span><br />
      <input type="range" id="pSlider" autocomplete="off" min="1" max="10" step="1" value="7" style="width: 75%;"
      oninput="document.getElementById('myPValue').innerHTML = this.value;">
      <span class="sliderValue" id="myPValue">7</span>

      <p />

      <span class="parameterLabels">distance (km)</span><br />
      <input type="range" id="distanceSlider" autocomplete="off" min="0" max="20" step="0.2" value="10" style="width: 75%;"
      oninput="document.getElementById('myDistanceValue').innerHTML = this.value;">
      <span class="sliderValue" id="myDistanceValue">10</span>

    </div>

    <div id="arogi-menu-bottom">
      <div id="arogi-sub-left">Demand Covered<br /><span id="solutionQuality"></span></div>
    </div>
  </div>



  <script>

  $(document).ready(function() {

    function parameterAjaxTrigger(){
      var useThisPValue = document.getElementById('myPValue').innerHTML;
      var useThisDistanceValue = document.getElementById('myDistanceValue').innerHTML;

      // update the GeoJSON with the latest parameter values
      // initialize the rest
      answeredGeoJson.properties.pValue = Number(useThisPValue);
      answeredGeoJson.properties.distanceValue = Number(useThisDistanceValue);
      answeredGeoJson.properties.efficacyPercentage = Number(-1);
      answeredGeoJson.properties.demandTotal = Number(-1);
      answeredGeoJson.properties.demandCovered = Number(-1);

      var useTheseMarkers = JSON.stringify(answeredGeoJson);


      // working animation...
      // document.getElementById('solutionQuality').innerHTML = "<img src=\"ajax-loader.gif\" />";

      $.ajax({
        type: 'POST',
        url: "interface/mclp_interface.py",  // deliver the data to this script... it will answer back with a solution
        data: {useTheseMarkers:useTheseMarkers},
        success: function(answerText)
        {
          // overwrites and displays existing answeredGeoJson...
          // with the response GeoJSON from the server
          answeredGeoJson = JSON.parse(answerText);
          document.getElementById('solutionQuality').innerHTML = ((answeredGeoJson.properties.efficacyPercentage)*100).toFixed(1) + "%";
          // document.getElementById('solutionQuality').innerHTML = answerText;


          // erase existing coverage circles, if they exist
          anotherCounter = 0;
          while (anotherCounter < simpleCount) {
              if (circleArray[anotherCounter] != undefined) {
                  map.removeLayer(circleArray[anotherCounter]);
                  map.removeLayer(redDots[anotherCounter]);
              anotherCounter++;
            }
          }

          // draw the new coverage circles...
          // and make them a little flashy
          setTimeout(function(){
            $(".myFade").animate({ fillOpacity: 0.2 }, 300, function() {
            });
          }, 100);
          // make an array of new circles
          simpleCount = 0;
          myRadius = (answeredGeoJson.properties.distanceValue * 1000);
          $.each(answeredGeoJson.features, function(i, v) {
              if (v.properties.facilityLocated == 1.0) {
                  answerCoordinates = v.geometry.coordinates;
                  circleArray[simpleCount] = new L.circle([answerCoordinates[1], answerCoordinates[0]], myRadius, {color: '#ffffff', fillColor: '#ffffff', fillOpacity: 0.9, weight:3, className:"myFade"});
                  redDots[simpleCount] = new L.circle([answerCoordinates[1], answerCoordinates[0]], 100, {color: '#ff0000', fillColor: '#ff0000', fillOpacity: 1, weight:3});
                  simpleCount++;
              }

          });
          //alert("number of circles: " + simpleCount);
          // add the coverage circles to the map
          newSimpleCount = 0;
          while (newSimpleCount < simpleCount) {
            circleArray[newSimpleCount].addTo(map);
            newSimpleCount++;
          }


          // clear the old map points and display the new ones
          // at least one version of these already exist because they are drawn on '$(document).ready'

          if (pointMarkers2 != undefined) {
            map.removeLayer(pointMarkers2);
          };

          pointMarkers = L.geoJson(answeredGeoJson, {
            pointToLayer: function (feature, latlng) {
              // return L.circleMarker(latlng, {radius: 1+(Math.log(feature.properties.pop+10)), fillColor: feature.properties.fillColor, color:"#000000",weight:0,opacity:1,fillOpacity: 0.9 });
              return L.circleMarker(latlng, {radius: 1.5, fillColor: "#ffff99", color:"#ffff99",weight:0,opacity:1,fillOpacity: 1 });
            }
          });
          pointMarkers.addTo(map);

          newSimpleCount = 0;
          while (newSimpleCount < simpleCount) {
            redDots[newSimpleCount].addTo(map);
            newSimpleCount++;
          }




        },
        error: function()
        {
          //// fail
          document.getElementById('solutionQuality').innerHTML = answerText;
          document.getElementById('solutionQuality').innerHTML = "( solution failed )";
        }

      });

    } // end of parameterAjaxTrigger function



    // test circle
    var circleArray = new Array();
    var redDots = new Array();
    simpleCount = 0;
    var pointMarkers;
    var pointMarkers2;

    parameterAjaxTrigger();

    $("#pSlider").on('change', function(){
      // call the following function to send the parameters to the solution-makin' script
      parameterAjaxTrigger();
    });

    $("#distanceSlider").on('change', function(){
      // call the following function to send the parameters to the solution-makin' script
      parameterAjaxTrigger();
    });



    // toggle the menus on and off
    $('#arogi-top-zone').click(function(){
      $('#arogi-menu-upper').toggle();
      $('#arogi-menu-middle').toggle();
      $('#arogi-menu-bottom').toggle();
    });


  });


  // add basemap tiles from Mapzen's Tangram
  var map = L.map('map', {zoomControl: false});
  var layer = Tangram.leafletLayer({
    scene: 'grayprint.yaml',
    attribution: '<a href="arogi.com">Arogi</a> | &copy; <a href="http://osm.org">OpenSteetMap</a> | <a href="https://mapzen.com/tangram" target="_blank">Mapzen</a>'
  });
  layer.addTo(map);
  map.attributionControl.setPrefix(""); // Leaflet prefix removed to afford an ordering change.

  L.control.scale().setPosition('bottomright').addTo(map);
  new L.Control.Zoom({ position: 'bottomright' }).addTo(map);


  // this gets called on document.ready since the map needs a bounding area and
  // the initial ajax call might take a long time.
  answeredGeoJson = defaultMarkers;
  var pointMarkers = L.geoJson(answeredGeoJson, {
    pointToLayer: function (feature, latlng) {
      return L.circleMarker(latlng);
    }
  });
  // but the points do not need to be shown
  //pointMarkers.addTo(map);

  map.fitBounds(pointMarkers, {padding:[140,140]});

  </script>

</body>

</html>
